---
id: one_to_many
sidebar_position: 1
description: ""
---

# Связь один ко многим

Даны 2 сущности:

- актер со свойствами имя, фамилия и дата рождения
- награда со свойствами название и год получения

У актера может быть много наград.\
Награда может принадлежать только одному актеру.

Данным сущностям соответствует следующая диаграмма:

```mermaid
erDiagram
    actor {
        int id PK
        text first_name
        text last_name
        date birth_date
    }
    award {
        int id PK
        int actor_id FK
        text title
        int year
    }
    actor ||..o{ award : ""
```

Этой диаграмме в SQL соответствуют следующие таблицы и связи:

```sql
-- удаление таблиц, если они уже созданы
drop table if exists actors, awards cascade;

create table actors
(
    -- для обеспечения ссылочной целостности задается первичный ключ (уникальный идентификатор строки) в главной таблице
    -- и внешний ключ в зависимой таблице
    id         int primary key, -- первичный ключ
    first_name text,
    last_name  text,
    birth_date date
);

create table awards
(
    id       int primary key,
    actor_id int references actors, -- внешний ключ
    title    text,
    year     int
);


-- вставка данных
insert into actors(id, first_name, last_name, birth_date)
values (1, 'Tom', 'Hanks', '1956-07-09'),
       (2, 'Robert', 'De Niro', '1943-08-17'),
       (3, 'Al', 'Pacino', '1940-04-25');

-- значения вставляемые в столбец actor_id должны присутствовать в главной таблице в столбце id
insert into awards(id, actor_id, title, year)
values (1, 1, 'Golden Globe Award for Best Actor – Motion Picture Musical or Comedy', 1989),
       (2, 1, 'Golden Globe Award for Best Actor – Motion Picture – Drama', 1994),
       (3, 2, 'Gotham Independent Film Tribute Award', 2012);

-- вывод данных из каждой таблицы по отдельности
select * from actors;

select * from awards;

-- вывод актеров и их наград (все столбцы из обеих таблиц)
select *
from actors
         left join awards on actors.id = awards.actor_id;

-- вывод только определенных столбцов
select first_name, last_name, title as award_title, year as award_year
from actors
    left join awards on actors.id = awards.actor_id;

-- вывод зависимой сущности в виде массива объектов
select 
  ac.id, 
  ac.first_name, 
  ac.last_name, 
  ac.birth_date,
  coalesce(json_agg(json_build_object(
    'id', aw.id, 'title', aw.title, 'year', aw.year))
      filter (where aw.id is not null), '[]')
        as awards
from actors ac
left join awards aw on ac.id = aw.actor_id
group by ac.id;
```
